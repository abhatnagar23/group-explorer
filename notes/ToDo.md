
# Ray's List

## General

 * GE help integration
 * Internal documentation
 * Rationalize coding style (add leading underscore to internal methods?)
 * Re-factor to hide internal implementations (e.g., js/DisplayXX classes)

## CayleyDiagram diagram panel

 * Hover help in big Cayley diagram (including chunking)
 * Keep labels from disappearing behind nodes with changing node/label sizes
 * Change label representations in visualizers?
 * Display raw element numbers for debugging?
 * Follow up approach in https://stackoverflow.com/questions/15558418/how-do-you-save-an-image-from-a-three-js-canvas for saving buffer
 * Add indication to Subgroups panel that subgroup is normal?

## Local files

 * Group Explorer
    * add groups
 * Group Info page
    * user-defined naming scheme
    * notes
 * Preferences
 * Saved sheets

## Sheets

 * SubgroupInfo
 * SolvableInfo
 * Z_nm group
 * Ad hoc

# Nathan's List

 * Sheets
    * Morphisms
       * Add a checkbox to the edit screen for including the domain and codomain in the
         morphism name (as in f:G->H).
       * Add a method to `VisualizerElement` for asking where in [0,1]x[0,1] a given group element sits.
         For now, just make that method a stub that returns (0,eltIndex/|G|).
         Call the method `elementToVirtualScreenCoords()`.
       * Add a checkbox to the edit screen for drawing many arrows or one.  In the former case,
         loop through all elements of the domain and for now assume the image of each is 0.
         But use `elementToVirtualScreenCoords()` to get the coordinates, even so.
       * Let's actually compute where elements sit, in four steps:
          * Update `VisualizerElement` so that it delegates the task of computing element locations
            to its `vizdisplay` member.
          * In DisplayDiagram, implement `elementToVirtualScreenCoords()` using THREE.js, as per here:
            https://stackoverflow.com/questions/11586527/converting-world-coordinates-to-screen-coordinates-in-three-js-using-projection
          * In DisplayCycleGraph, implement `elementToVirtualScreenCoords()` using the already-computed coords,
            which are in `cycleGraph.positions`, indexed by element.
          * In DisplayMulttable, implement `elementToVirtualScreenCoords()` using the permutation stored in
            `multtable.position`.
       * Write a function that takes as input a domain group D and a list DE of elements of it,
         plus a codomain group C and a list CE of elements of it, of equal length to DE,
         and it computes the simplest homomorphism extending DE[1]:=CE[1],...,DE[n]:=CE[n],
         or returns null if there is no such homomorphism.  (Simplest means everything unspecified
         maps to the identity.)  Call it `getFullMap()`.  Use this algorithm:
```
// generate how hom behaves on subgroup of domain defined by DE
var Dsubgroup = DE.slice();
var Csubgroup = CE.slice();
for ( var i = 0 ; i < Dsubgroup.length ; i++ ) {
    for ( var j = 0 ; j < DE.length ; j++ ) {
        const maybeNewElt = D.multiply( Dsubgroup[i], DE[j] );
        if ( Dsubgroup.indexOf( maybeNewElt ) == -1 ) {
            Dsubgroup.push( maybeNewElt );
            Csubgroup.push( C.multiply( f( Dsubroup[i] ), f( DE[j] ) ) );
        }
    }
}
// extend to whole domain by mapping everything else to the identity
for ( var i = 0 ; i < D.elements.length ; i++ ) {
    if ( Dsubgroup.indexOf( i ) == -1 ) {
        Dsubgroup.push( i );
        Csubgroup.push( 0 );
    }
}
// verify that it's actually a hom now
for ( var i = 0 ; i < Dsubgroup.length ; i++ ) {
    for ( var j = 0 ; j < Dsubgroup.length ; j++ ) {
        const prodInDomain = D.multiply( Dsubgroup[i], Dsubgroup[j] );
        const image1 = f( Dsubgroup[i] );
        const image2 = f( Dsubgroup[j] );
        if ( prodInDomain != C.multiply( image1, image2 ) ) return null;
    }
}
// yup, it's a hom; turn it into one that's easy to use
var result = [ ];
for ( var i = 0 ; i < D.elements.length ; i++ )
    result.push( Csubgroup[Dsubgroup.indexOf( i )] );
return result;
```
       * Whenever the morphism element is constructed or deserialized, call this function to
         find out what its current meaning is, and store it in an internal field that is not
         part of the serialization process.  Call that field `_map`.
       * Add these HTML elements to the end of the morphism element edit pane:
          * A section header reading "Define the homomorphism here:"
          * A two-column table (left column for `f(_)=_` output, right for Remove buttons)
          * A row containing:
             * "Add:" button
             * `f( [domain element drop-down] )`
             * `= [codomain element drop-down]`
          * A statement that all elements not in the subgroup generated by the chosen domain
            elements map to the identity in the codomain by default.
          * "Preview" button (with a note that it opens in a new window)
       * Initialize the morphism element with empty lists for its domain and codomain generators.
       * Implement `loadEdits()` to clear the table and then populate it with either at least one
         `f(_)=_` and Remove pair or a single row saying there are no entries in the table yet.
       * Write a function that populates the domain element drop-down with the set of domain
         elements that aren't in the subgroup generated by the domain elements in the table;
         call that function at the end of `loadEdits()`.  (If the morphism is totally defined,
         it should instead empty all optionsn from the drop-down and disable its whole row.)
       * Write a function that populates the codomain element drop-down with the set of codomain
         elements for which the new assignment has at least one extension to a valid homomorphism;
         call that function at the end of `loadEdits()`, after the previous one.  (If the domain
         drop-down is empty/disabled, it should just empty the codomain one, too.)
       * Also call that function whenever the selection in the domain element drop-down changes.
       * When the edit pane opens up, store in the edit element itself copies of the domain and
         codomain generator lists from the morphism element itself.
       * Implement the Add button handler to extend the two arrays in the edit element
         and update the table as well, then set the two drop-downs up again.
       * Implement the Remove button handler to splice the two arrays in the edit element
         and update the table as well, then set the two drop-downs up again.
       * Implement the Preview button to generate HTML for another window, then open the window,
         then set it as the body's inner HTML.  Include text saying that you can close the
         window when you're done.
       * Extend `saveEdits()` so that the two arrays in the edit element are placed back into the
         morphism element itself, and `_map` is updated with the latest result of `getFullMap()`
         applied to those two arrays.
       * Update the drawing of multi-arrow morphisms so that no longer does everything map to the
         identity, but now instead we look up where things go using `_map`.
       * Add to the edit pane a checkbox for whether to show, with the morphism name,
         its list of generating pairs (one or more lines of hte form `f(_)=_`, or the
         statement that everything maps to the identity).  Create the serialization and
         deserialization code for this new option.
       * Update the morphism drawing code to respect this new option.
       * Add to the edit pane a checkbox for whether to show, with the morphism name,
         an assessment of whether it is 1-1, onto, neither, or both.  Create the serialization
         and deserialization code for this new option.
       * Update the morphism drawing code to respect this new option.
    * Extend the toJSON() and fromJSON() in CayleyDiagram.html to also respect:
       * node colors: `Cayley_diagram.nodes[i].nodeColor` then same update routine or `updateHighlights()`
         (Is this the same as node highlights?)
       * diagram name: global var in HTML page, `Diagram_name`, plus the
         drop-down selector with id `'#diagram-select'` (then `displayGraphic()`)
       * all the rest of the Diagram panel needs to wait until I talk to Ray
       * background color:
         `Graphic_context.renderer.getClearColor().toArray()` and
         `new THREE.Color( that_array[0], that_array[1], that_array[2] )`
       * node positions: `Cayley_diagram.nodes[i].point.x` (y, z), then update diagram with `updateNodes()`
       * node radii: `Cayley_diagram.nodes[i].radius` then same (original) update routine
       * arc curvature: once it's implemented later
       * chunking: once it's implemented later
 * Rename Cycle Diagram HTML page to Cycle Graph instead
 * Add an object of symmetry for Z_1: something with no symmetry
 * Design how permalinks to GE resources should work and add a plan for
   implementation.  Goal: As many things as possible should be linkable
   directly so that students, instructors, etc. can just copy the URL as if
   it were Google maps and paste it into an email, and anyone can jump right
   to the visualization the first user was seeing.
 * Consider how to improve the default style of the three visualizations:
    * Remove colored background from all three?
    * Investigate drawing Cycle Graphs with SVGs; let the browser do the
      rendering optimizations and get free vector graphics as a result.
    * Investigate how to get Cayley Diagrams to look more like VGT and less
      like GE2.0.
    * Consider how to create an exporter for 3D Cayley Diagrams to SVGs,
      for users to download for use in contexts where they want vector graphics.
       * [Recall your 3D SVG library](https://github.com/nathancarter/svg3d)
    * Consider letting them also download PDF versions.  Note that PDFKit can
      do this if you have SVGs first; or you can skip SVGs and go stright to
      PDFs instead.  Either way, here are some useful links:
       * [Demo PDF made by PDFKit](https://github.com/foliojs/pdfkit/blob/master/demo/out.pdf)
         (See last page on which a tiger SVG is embedded.)
       * [The source code that created the tiger page](https://github.com/foliojs/pdfkit/blob/83f5f7243172a017adcf6a7faa5547c55982c57b/demo/test.js#L48)
       * [The tiger data in JSON-like format](https://raw.githubusercontent.com/foliojs/pdfkit/master/demo/tiger.js)

# Anyone's List (as yet unclaimed)

## Features

 * Get the following stuff into the heading on the main page:
    * Simple logo, w/version number
    * Contributors' names
    * Link to help files (or to help stub if they're not yet done)
    * [GitHub icon](https://github.com/logos) linking to this
      source code repository
 * Improve the Subgroups view so that instead of using HTML with MathJax
   inside, the entire "H_{index} = < element names >" portion is MathJax.
 * Change &lt;select&gt; elements that use formatted math strings to use hand-rolled menus
   with mathml instead of text (similar to menus in Subgroups view)

## Bug fixes
 * Table on main page does not show which column is sorted at first (until you click one).
 * Setting line thickness to minimum does not work; it gets reset to a thicker value.
 * Render multiple-character element names in same font as single-character names. (By default, MathJax renders
   single-character elements in italic, multiple-character in normal font, so you get odd-looking element
   names like &#x27E8;<i>e</i>,fr&#x27E9; in D<sub>4</sub> x &Zopf;<sub>2</sub>.)
 * Eliminate juxtapositions of dissimilar fonts in, e.g., visualizer titles (perhaps make entire title mathml?)
 * Adjust radial scaling in, e.g., A_5 generated by `[(0 1 2 3 4),0,0,0][(0 1)(2 3),2,0,1]`
 * Fix test for circular/rotary layout in `CayleyDiagram.setStrategies`
