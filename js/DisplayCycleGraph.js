

class DisplayCycleGraph {

   constructor(options) {
      Log.log('DisplayCycleGraph');

      DisplayCycleGraph._setDefaults();

      if (options === undefined) {
         options = {};
      }

      let width = (options.width === undefined) ? DisplayCycleGraph.DEFAULT_CANVAS_WIDTH : options.width;
      let height = (options.height === undefined) ? DisplayCycleGraph.DEFAULT_CANVAS_HEIGHT : options.height;
      if (options.container !== undefined) {
         // take canvas dimensions from container (if specified), option, or default
         width = options.container.width();
         height = options.container.height();
      }
      this.canvas = $(`<canvas width="${width}" height="${height}">`)[0];
      this.context = this.canvas.getContext('2d');
      this.options = options;
      if ( options.container !== undefined) {
         options.container.append(this.canvas);
      }
      this.zoom = 1;  // user-supplied scale factor multiplier
      this.translate = {dx: 0, dy: 0};  // user-supplied translation, in screen coordinates
      this.transform = new THREE.Matrix3();  // current cycleGraph -> screen transformation
   }

   static _setDefaults() {
      DisplayCycleGraph.DEFAULT_MIN_CANVAS_HEIGHT = 200;
      DisplayCycleGraph.DEFAULT_MIN_CANVAS_WIDTH = 200;
      DisplayCycleGraph.DEFAULT_MIN_RADIUS = 30;
      DisplayCycleGraph.DEFAULT_ZOOM_STEP = 0.1;  // zoom in/zoom out step
   }

   getImageURL(cycleGraph) {
      this.showSmallGraphic(cycleGraph);
      const img = new Image();
      img.src = this.canvas.toDataURL();
      return img;
   }

   // This function makes a small graphic by doing the exact same thing
   // it would do to create a large graphic, with one exception:
   // It passes an optional second parameter to that routine, so that
   // it hides all element names, thus making the vertices in the graph
   // much smaller, and thus the image itself much smaller as well.
   showSmallGraphic(cycleGraph) {
      this.showLargeGraphic( cycleGraph, true );
   }

   // Draws the visualization at an optimal (large) size.
   // All the data needed about the group and how to lay it out in the
   // plane has been computed at construction time by the cycleGraph
   // object, and we can leverage that here and just do drawing.
   // The second parameter, which defaults to true, says whether to omit
   // the names inside the elements.  (False == normal behavior, true
   // == a smaller graphic in the end, useful for thumbnails.)
   showLargeGraphic(cycleGraph, hideNames = false) {
      // save the cycle graph for use by other members of this object
      this.cycleGraph = cycleGraph;
      const bbox = cycleGraph.bbox;

      // paint the background
      this.context.setTransform(1, 0, 0, 1, 0, 0);  // reset the transform, so repeated calls paint entire background
      this.context.fillStyle = '#C8C8E8';
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

      // calculate node radius in cycleGraph units
      const max_cg_dimension = Math.max(bbox.right - bbox.left, bbox.top - bbox.bottom);
      const pixels2cg = (val) => val * Math.min((bbox.right-bbox.left)/this.canvas.width, (bbox.top-bbox.bottom)/this.canvas.height);
      const bestSize = (r) => r*Math.max(10, 8 + 2.5*max_cg_dimension/cycleGraph.closestTwoPositions, 200/r); // min size = 200
      if (hideNames) {
         this.radius = pixels2cg(6 * this.canvas.width / bestSize(6));  // size for nodes in thumbnails
      } else {
         this.radius = Math.min(cycleGraph.closestTwoPositions/2.5, max_cg_dimension/10);
      }

      // set up scaling, translation from cycleGraph units to screen pixels
      // leave room around bbox for node radius + space (which we set to another node radius)
      const margin = 2 * this.radius;
      // canvas / bbox ratio
      const raw_scale = Math.min(this.canvas.width / (bbox.right - bbox.left + 2 * margin),
                                 this.canvas.height / (bbox.top - bbox.bottom + 2 * margin) );
      // scale with zoom
      let scale = this.zoom * raw_scale;

      // translate center of scaled bbox to center of canvas
      let x_translate = (this.canvas.width - scale*(bbox.right + bbox.left))/2;
      let y_translate = (this.canvas.height - scale*(bbox.top + bbox.bottom))/2;

      // algorithm doesn't cover trivial group, treat it specially
      if (this.cycleGraph.group.order == 1) {
         const sideLength = Math.min(this.canvas.width, this.canvas.height);
         this.radius = sideLength / 10;
         scale = this.zoom * sideLength / (sideLength + 4 * this.radius);
         x_translate = this.canvas.width / 2;
         y_translate = this.canvas.height / 2;
      }

      // set transform to include translation generated by user drag-and-drop
      this.context.setTransform(scale, 0, 0, scale, x_translate + this.translate.dx, y_translate + this.translate.dy);

      // draw all the paths first, because they're behind the vertices
      this.context.lineWidth = 1/scale;
      cycleGraph.cyclePaths.forEach( points => {
         this.context.beginPath();
         points.forEach( ( point, index ) => {
            this.context[index == 0 ? 'moveTo' : 'lineTo']( point.x, point.y );
         } );
         this.context.stroke();
      } );

      // draw all elements as vertices, on top of the paths we just drew
      cycleGraph.positions.forEach( ( pos, elt ) => {
         // draw the background, defaulting to white, but using whatever
         // highlighting information for backgrounds is in the cycleGraph
         this.context.beginPath();
         this.context.arc( pos.x, pos.y, this.radius, 0, 2 * Math.PI );
         if ( cycleGraph.highlights && cycleGraph.highlights.background
           && cycleGraph.highlights.background[elt] ) {
            this.context.fillStyle = cycleGraph.highlights.background[elt];
         } else {
            this.context.fillStyle = '#fff';
         }
         this.context.fill();

         // over the background, only if there is "top"-style highlighting,
         // draw a little cap on the top of the vertex's circle
         if ( cycleGraph.highlights && cycleGraph.highlights.top
           && cycleGraph.highlights.top[elt] ) {
            this.context.beginPath();
            this.context.arc( pos.x, pos.y, this.radius, -3*Math.PI/4, -Math.PI/4 );
            this.context.fillStyle = cycleGraph.highlights.top[elt];
            this.context.fill();
         }

         // draw the border around the node, defaulting to thin black,
         // but using whatever highlighting information for borders is
         // in the cycleGraph, and if it's there, making it thick
         this.context.beginPath();
         this.context.arc( pos.x, pos.y, this.radius, 0, 2 * Math.PI );
         if ( cycleGraph.highlights && cycleGraph.highlights.border
           && cycleGraph.highlights.border[elt] ) {
            this.context.strokeStyle = cycleGraph.highlights.border[elt];
            this.context.lineWidth = 5/scale;
         } else {
            this.context.strokeStyle = '#000';
            this.context.lineWidth = 1/scale;
         }
         this.context.stroke();
      } );

      // all done except for labels
      if (hideNames) {
         return;
      }

      // transform used to position the labels in screen space
      //   calculated even if we don't render labels because they're too small,
      //   since select method also uses this to determine element from node click
      this.transform.set(scale, 0,     x_translate + this.translate.dx,
                         0,     scale, y_translate + this.translate.dy,
                         0,     0,     1);
      // calculate the pre_image of the screen, in order to skip drawing labels on nodes not in view
      const upper_left = new THREE.Vector2(0, 0).applyMatrix3(new THREE.Matrix3().getInverse(this.transform));
      const lower_right = new THREE.Vector2(this.canvas.width, this.canvas.height).applyMatrix3(new THREE.Matrix3().getInverse(this.transform));
      const pre_image = {minX: upper_left.x, minY: upper_left.y, maxX: lower_right.x, maxY: lower_right.y};

      // pick sensible font size and style for node labels
      // find longest rep, find it's size in 14pt font, and choose a font size that lets rep fit within the default node
      // (this is done in screen coordinates because scaling text from cycleGraph coordinates had too many gotchas -- rwe)
      this.context.setTransform(1,0,0,1,0,0);
      this.context.font = '14pt Arial';
      const longest_label_length = cycleGraph.group.representation.reduce(
         (longest, rep) => Math.max(longest, this.context.measureText(mathml2text(rep)).width),
         0 );

      // "1" is to make short, tall names (like g^2) fit heightwise
      // "22" is a magic number that combines diameter/radius, effect of curved edges, point/pixel ratio, etc.
      //   -- but don't make font bigger than 50pt in any case
      const fontScale = Math.min(50, scale * this.radius * Math.min(1, 22 / longest_label_length));

      // skip out if this font would be too small to see anyhow
      //   (this cuts the rendering time for a large group substantially -- ~30-40% for Tesseract)
      if (fontScale < 1.5) {
         return;
      }

      // now draw all the labels, skipping nodes outside of the pre_image
      this.context.font = `${fontScale.toFixed(6)}pt Arial`;
      this.context.textAlign = 'center';
      this.context.textBaseline = 'middle';
      this.context.fillStyle = '#000';

      const pos_vector = new THREE.Vector2();
      cycleGraph.positions.forEach( ( pos, elt ) => {
         // skip nodes that are off the screen
         //   up to half the rendering time for a large group can be spent drawing labels
         //   so skipping nodes not in view can be a substantial savings
         if (   pos.x < pre_image.minX || pos.x > pre_image.maxX
             || pos.y < pre_image.minY || pos.y > pre_image.maxY) {
            return;
         }

         // write the element name inside it
         var label = hideNames ? ' ' : mathml2text( cycleGraph.group.representation[elt] );
         const loc = pos_vector.set(pos.x, pos.y).applyMatrix3(this.transform);
         this.context.fillText( label, loc.x, loc.y );
      } );
   }

   // interface for zoom-to-fit GUI command
   reset() {
      this.zoom = 1;
      this.translate = {dx: 0, dy: 0};
   }

   // increase magnification proportional to its current value,
   zoomIn() {
      this._centeredZoom((1 + DisplayCycleGraph.DEFAULT_ZOOM_STEP) - 1);
   }

   // decrease magnification in a way that allows you to zoom in and out and return to its original value
   zoomOut() {
      this._centeredZoom(1/(1 + DisplayCycleGraph.DEFAULT_ZOOM_STEP) - 1);
   }

   // changing the translation keeps the center of the model centered in the canvas
   _centeredZoom(dZoom) {
      this.zoom = this.zoom * (1 + dZoom);
      this.move(this.translate.dx * dZoom, this.translate.dy * dZoom);
   }

   // deltaX, deltaY are in screen coordinates
   move(deltaX, deltaY) {
      this.translate.dx += deltaX;
      this.translate.dy += deltaY;
   }

   // given screen coordinates, returns element associated with node,
   //   or 'undefined' if not within one radius
   select(screenX, screenY) {
      // compute cycleGraph coordinates from screen coordinates by inverting this.transform
      const cg_coords = new THREE.Vector2(screenX, screenY).applyMatrix3(new THREE.Matrix3().getInverse(this.transform));
      const index = this.cycleGraph.positions.findIndex( (pos) =>
         Math.abs(pos.x - cg_coords.x) < this.radius && Math.abs(pos.y - cg_coords.y) < this.radius
      );
      return (index == -1) ? undefined : index;
   }
}
