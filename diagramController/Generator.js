// @flow

import {Group, Cayley_Diagram_View} from '../CayleyDiagram.js';
import BitSet from '../js/BitSet.js';
import {CayleyGeneratorFromStrategy, DIRECTION_INDEX, AXIS_NAME} from '../js/CayleyGenerator.js';
import MathML from '../js/MathML.js';
import Menu from '../js/Menu.js';
import Template from '../js/Template.js';
import XMLGroup from '../js/XMLGroup.js';

import * as DC from './diagram.js';

/*::
import type {Layout, Direction, StrategyParameters} from '../js/CayleyDiagramView.js';
*/

export default class Generator {
/*::
   static axis_label: {[key: Layout]: {[key: Direction]: string}};
   static axis_image: {[key: Layout]: {[key: Direction]: string}};
   static orders: Array<Array<string>>;
 */
   static init () {
      // layout choices (linear/circular/rotated), direction (X/Y/Z)
      DC.Generator.axis_label = {
         linear:   { X: MathML.sans('<mtext>Linear in&nbsp;</mtext><mi>x</mi>'),
                     Y: MathML.sans('<mtext>Linear in&nbsp;</mtext><mi>y</mi>'),
                     Z: MathML.sans('<mtext>Linear in&nbsp;</mtext><mi>z</mi>') },
         circular: { YZ: MathML.sans('<mtext>Circular in&nbsp;</mtext><mi>y</mi><mo>,</mo><mi>z</mi>'),
                     XZ: MathML.sans('<mtext>Circular in&nbsp;</mtext><mi>x</mi><mo>,</mo><mi>z</mi>'),
                     XY: MathML.sans('<mtext>Circular in&nbsp;</mtext><mi>x</mi><mo>,</mo><mi>y</mi>') },
         rotated:  { YZ: MathML.sans('<mtext>Rotated in&nbsp;</mtext><mi>y</mi><mo>,</mo><mi>z</mi>'),
                     XZ: MathML.sans('<mtext>Rotated in&nbsp;</mtext><mi>x</mi><mo>,</mo><mi>z</mi>'),
                     XY: MathML.sans('<mtext>Rotated in&nbsp;</mtext><mi>x</mi><mo>,</mo><mi>y</mi>') },
      };

      DC.Generator.axis_image = {
         linear:   { X: 'axis-x.png', Y: 'axis-y.png', Z: 'axis-z.png' },
         circular: { YZ: 'axis-yz.png', XZ: 'axis-xz.png', XY: 'axis-xy.png'},
         rotated:  { YZ: 'axis-ryz.png', XZ: 'axis-rxz.png', XY: 'axis-rxy.png'},
      };

      // wording for nesting order
      DC.Generator.orders = [
         [],
         [MathML.sans('<mtext>N/A</mtext>')],
         [MathML.sans('<mtext>inside</mtext>'),
          MathML.sans('<mtext>outside</mtext>')],
         [MathML.sans('<mtext>innermost</mtext>'),
          MathML.sans('<mtext>middle</mtext>'),
          MathML.sans('<mtext>outermost</mtext>')],
         [MathML.sans('<mtext>innermost</mtext>'),
          MathML.sans('<mtext>second innermost</mtext>'),
          MathML.sans('<mtext>second outermost</mtext>'),
          MathML.sans('<mtext>outermost</mtext>')],
         [MathML.sans('<mtext>innermost</mtext>'),
          MathML.sans('<mtext>second innermost</mtext>'),
          MathML.sans('<mtext>middle</mtext>'),
          MathML.sans('<mtext>second outermost</mtext>'),
          MathML.sans('<mtext>outermost</mtext>')]
      ];

      $('#multiplication-control input').each(
         (_inx, el) => el.addEventListener('click', () => DC.Generator.setMult(`${el.id}`))
      );
   }

   /*
    * Draw Generator table
    */
   static draw () {
      // clear table
      const $generation_table = $('#generation-table');
      $generation_table.children().remove();

      // add a row for each strategy in Cayley diagram
      const strategies = Cayley_Diagram_View[0].strategy_parameters;
      if (strategies == undefined) {
         $('#generation-table').html(
            '<tr style="height: 3em"><td></td><td style="width: 25%"></td><td style="width: 40%"></td><td></td></tr>');
      } else {
         strategies.forEach( (strategy, inx) => {
            $generation_table.append($(eval(Template.HTML('generation-table-row-template'))));
         } );
      }
   }

   /*
    * Show option menus for the columns of the Generator table
    */
   static showGeneratorMenu (click_location /*: eventLocation */, strategy_index /*: number */) {
      $('#bodyDouble').click();

      // show only elements not generated by previously applied strategies
      const generator = ((Cayley_Diagram_View[0].generator /*: any */) /*: CayleyGeneratorFromStrategy */);
      const eligibleGenerators = ( (strategy_index == 0) ?
                                   new BitSet(Group[0].order, [0]) :
                                   generator.strategies[strategy_index-1].elements.clone() )
            .complement().toArray();


      // returns an HTML string with a list element for each arrow that can be added to the arrow-list
      const makeEligibleGeneratorList = () /*: html */ => {
         const template_html = Template.HTML('generation-generator-menu-item-template');
         const result = eligibleGenerators
               .reduce( (generators, generator) => (generators.push(eval(template_html)), generators), [] )
               .join('');
         return result;
      }

      const $menus = $(eval(Template.HTML('generation-generator-menu-template')))
            .appendTo('#generation-table');

      Menu.addMenus($menus, click_location, DC.clickHandler);
   }

   static showAxisMenu (click_location /*: eventLocation */, strategy_index /*: number */) {
      $('#bodyDouble').click();

      // previously generated subgroup must have > 2 cosets in this subgroup
      //   in order to show it in a curved (circular or rotated) layout
      const generator = ((Cayley_Diagram_View[0].generator /*: any */) /*: CayleyGeneratorFromStrategy */);
      const curvable =
            (generator.strategies[strategy_index].elements.popcount()
             /  ((strategy_index == 0) ? 1 : generator.strategies[strategy_index - 1].elements.popcount()))
      > 2;

      const $menus = $(eval(Template.HTML('generation-axis-menu-template')))
            .appendTo('#generation-table');

      Menu.addMenus($menus, click_location, DC.clickHandler);
   }

   static showOrderMenu (click_location /*: eventLocation */, strategy_index /*: number */) {
      $('#bodyDouble').click();

      const generator = ((Cayley_Diagram_View[0].generator /*: any */) /*: CayleyGeneratorFromStrategy */);
      const makeStrategyList = () => {
         const template = Template.HTML('generation-order-menu-item-template');
         const result = generator.strategies
               .reduce( (orders, _strategy, order) => (orders.push(eval(template)), orders), [])
               .join('');
      return result;
      };
      
      const num_strategies = generator.strategies.length;
      const $menus = $(eval(Template.HTML('generation-order-menu-template')))
            .appendTo('#generation-table');

      Menu.addMenus($menus, click_location, DC.clickHandler);
   }

   static makeOrganizeByMenu () {
      const template = Template.HTML('generation-organize-by-menu-item-template');
      const result = Group[0].subgroups
           .reduce( (list, subgroup, inx) => {
              if (subgroup.order != 1 && subgroup.order != Group[0].order) {  // only append non-trivial subgroups
                 list.push(eval(template));
              }
              return list;
           }, [] )
         .join('');
      return result;
   }

   /*
    * Perform actions directed by option menus
    */
   static organizeBy (subgroup_index /*: number */) {
      // get subgroup generators
      const subgroup_generators = Group[0].subgroups[subgroup_index].generators.toArray();

      // add subgroup generator(s) to start of strategies
      for (let g = 0; g < subgroup_generators.length; g++) {
         DC.Generator.updateGenerator(g, subgroup_generators[g]);
         DC.Generator.updateOrder(g, g);
      }
   }

   static updateGenerator (strategy_index /*: number */, generator /*: number */) {
      const strategy_parameters = ((Cayley_Diagram_View[0].strategy_parameters /*: any */) /*: Array<StrategyParameters> */);
      strategy_parameters[strategy_index].generator = generator;
      updateStrategies(strategy_parameters);
   }

   static updateAxes (strategy_index /*: number */, layout /*: Layout */, direction /*: Direction */) {
      const strategy_parameters = ((Cayley_Diagram_View[0].strategy_parameters /*: any */) /*: Array<StrategyParameters> */);
      strategy_parameters[strategy_index].layout = layout;
      strategy_parameters[strategy_index].direction = direction;
      updateStrategies(strategy_parameters);
   }

   static updateOrder (strategy_index /*: number */, order /*: number */) {
      const strategy_parameters = ((Cayley_Diagram_View[0].strategy_parameters /*: any */) /*: Array<StrategyParameters> */);
      const other_strategy = strategy_parameters.findIndex( (strategy) => strategy.nestingLevel == order );
      strategy_parameters[other_strategy].nestingLevel = strategy_parameters[strategy_index].nestingLevel;
      strategy_parameters[strategy_index].nestingLevel = order;
      updateStrategies(strategy_parameters);
   }

   /*
    * Drag-and-drop generation-table rows to re-order generators
    */
   static dragStart (dragstartEvent /*: DragEvent */) {
      const target = ((dragstartEvent.target /*: any */) /*: HTMLElement */);
      const dataTransfer = ((dragstartEvent.dataTransfer /*: any */) /*: DataTransfer */);
      dataTransfer.setData('text/plain', target.textContent);
   }

   static drop (dropEvent /*: DragEvent */) {
      dropEvent.preventDefault();
      const target = ((dropEvent.target /*: any */) /*: HTMLElement */);
      const dataTransfer = ((dropEvent.dataTransfer /*: any */) /*: DataTransfer */);
      const dest = parseInt(target.textContent);
      const src = parseInt(dataTransfer.getData('text/plain'));
      const strategy_parameters = ((Cayley_Diagram_View[0].strategy_parameters /*: any */) /*: Array<StrategyParameters> */);
      strategy_parameters.splice(dest-1, 0, strategy_parameters.splice(src-1, 1)[0]);
      updateStrategies(strategy_parameters);
   }

   static dragOver (dragoverEvent /*: DragEvent */) {
         dragoverEvent.preventDefault();
   }

   static setMult (rightOrLeft /*: string */) {
      Cayley_Diagram_View[0].right_multiply = (rightOrLeft == 'right');
   }
}

/*
 * Internal routines, not exported
 */

// Remove redundant generators, check whether there are enough elements to use curved display
function refineStrategies (strategies /*: Array<StrategyParameters> */) {
   const generators_used = new BitSet(Group[0].order);
   let elements_generated = new BitSet(Group[0].order, [0]);
   strategies = strategies.reduce( (nonRedundantStrategies, strategy) => {
      if (!elements_generated.isSet(strategy.generator)) {
         const old_size = elements_generated.popcount();
         generators_used.set(strategy.generator);
         elements_generated = Group[0].closure(generators_used);
         const new_size = elements_generated.popcount();

         if (strategy.layout != 'linear' && new_size / old_size < 3) {
            strategy.layout = 'linear';
            if (strategy.direction != 'X' && strategy.direction != 'Y' && strategy.direction != 'Z') {
               strategy.direction = 'X';
            }
         }

         nonRedundantStrategies.push(strategy);
      }
      return nonRedundantStrategies;
   }, []);

   // fix nesting order
   strategies.slice().sort( (a,b) => a.nestingLevel - b.nestingLevel ).map( (el,inx) => (el.nestingLevel = inx, el) );

   // add elements to generate entire group; append to nesting
   if (elements_generated.popcount() != Group[0].order) {
      // look for new element -- we know one exists
      const new_generator = ((elements_generated
                              .complement()
                              .toArray()
                              .find( (el) => Group[0].closure(generators_used.clone().set(el)).popcount() == Group[0].order ) /*: any */) /*: groupElement */);
      // among linear layouts, try to find a direction that hasn't been used yet
      const unused_direction =
            strategies.reduce( (unused_directions, {layout, direction}) => {
               if (layout == 'linear') {
                  unused_directions.clear(DIRECTION_INDEX[direction]);
               }
               return unused_directions;
            }, new BitSet(3).setAll() )
            .first();
      const new_direction = (unused_direction == undefined) ? AXIS_NAME[0] : AXIS_NAME[unused_direction];
      strategies.push({generator: new_generator, layout: 'linear', direction: new_direction, nestingLevel: strategies.length});
   }

   return strategies;
}

function updateStrategies (new_strategies /*: Array<StrategyParameters> */) {
   const strategies = refineStrategies(new_strategies);
   Cayley_Diagram_View[0].setDiagram(Group[0], undefined, strategies);
   DC.update();
}
